use std::fs::read_file;
use std::fs::write_file;
use std::process::cmd;
use std::convert::parse_number;

fun is_digit(c) {
    return str_contains("0123456789", c);
}

fun str_contains(haystack, needle) {
    let idx = 0;
    while idx < haystack.length {
        if haystack[idx] == needle {
            return true;
        } else {
            idx = idx + 1;
        }
    }
    return false;
}

fun is_alpha(c) {
    return str_contains("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", c);
}

fun is_alphanum(c) {
    return is_alpha(c) or is_digit(c);
}

enum OpCode {
    PushInt,
    PushString,
    PushMem,
    Argv,
    Argc,
    Add,
    Sub,
    Mul,
    Divmod,
    Equal,
    NotEqual,
    Lt,
    Gt,
    Shl,
    Shr,
    Bor,
    Band,
    Dup,
    Drop,
    Rotate,
    Swap,
    Over,
    Store8,
    Load8,
    Store16,
    Load16,
    Store32,
    Load32,
    Store64,
    Load64,
    Call,
    Syscall1,
    Syscall2,
    Syscall3,
    Syscall4,
    Syscall5,
    Syscall6,
}

class Consts { }
class Procs { }
class Memory { }
class Included { }

enum BlockType {
    Root,
    If,
    Else,
    While,
    Proc,
}

class StackNode {
    init(op, prev) {
        this.op = op;
        this.prev = prev;
    }
}

class Stack {
    init() {
        this.head = nil;
    }
    push(op) {
        let current = this.head;
        this.head = StackNode(op, current);
    }
    pop() {
        let last = this.head;
        this.head = last.prev;
        return last.op;
    }
    resolve() {
        while this.head.prev != nil {
            let op = this.pop();
            if op.type == OpCode.Add {
                let a = this.pop();
                let b = this.pop();
                assert a.type == OpCode.PushInt and b.type == OpCode.PushInt, "const expression binary operations only work on integers";
                this.push(Op(OpCode.PushInt, a.operand + b.operand));
            } else if op.type == OpCode.Mul {
                let a = this.pop();
                let b = this.pop();
                assert a.type == OpCode.PushInt and b.type == OpCode.PushInt, "const expression binary operations only work on integers";
                this.push(Op(OpCode.PushInt, a.operand * b.operand));
            } else if op.type == OpCode.Sub {
                let a = this.pop();
                let b = this.pop();
                assert a.type == OpCode.PushInt and b.type == OpCode.PushInt, "const expression binary operations only work on integers";
                this.push(Op(OpCode.PushInt, b.operand - a.operand));
            }
        }
        assert this.head.op.type == OpCode.PushInt, "const expression must evaluate to a integer";
        return this.head.op.operand;
    }
}

class Block {
    init(id, type) {
        this.type = type;
        this.prev = nil;
        this.id = id;
    }
}

class Op {
    init(type, operand) {
        this.type = type;
        this.operand = operand;
    }
}

fun is_separator(c) {
    return c == " "
        or c == "\n"
        or c == "\r";
}

class Lexer {
    init(source) {
        this.block_counter = 1;
        this.source = source;
        this.line = 0;
        this.col = 0;
        this.ptr = 0;
        this.output = "";
        this.str_count = 0;
        this.data = "";
        this.memory = Memory();
        this.mem_capacity = 0;
        this.consts = Consts();
        this.blocks = Block(0, BlockType.Root);
        this.stack = Stack();
        this.processing_const = false;
        this.procs = Procs();
        this.first_non_include_passed = false;
        this.included = Included();
    }
    matches(s) {
        let c = "";
        for let i = 0; i < s.length; i = i + 1 {
            c = c + this.source[this.ptr + i];
        }
        return s == c;
    }
    trim() {
        while this.ptr < this.source.length and is_separator(this.source[this.ptr]) {
            if this.source[this.ptr] == "\n" {
                this.line = this.line + 1;
            }
            this.ptr = this.ptr + 1;
        }
    }
    skip_line() {
        while this.ptr < this.source.length and this.source[this.ptr] != "\n" {
            this.ptr = this.ptr + 1;
        }
        this.trim();
    }
    next_word() {
        let word = this.peek_word();
        this.move_word(word);
        return word;
    }
    peek_word() {
        this.trim();
        let ptr = this.ptr;
        let word = "";
        while ptr < this.source.length and !is_separator(this.source[ptr]) {
            word = word + this.source[ptr];
            ptr = ptr + 1;
        }
        return word;
    }
    move_word(word) {
        this.ptr = this.ptr + word.length;
    }
    lex() {
        while this.ptr < this.source.length {
            this.declaration();
        }
    }
    declaration() {
        let word = this.peek_word();
        if word == "mem" {
            this.first_non_include_passed = true;
            this.move_word(word);
            this.memory_declaration();
        } else if word == "const" {
            this.first_non_include_passed = true;
            this.move_word(word);
            this.const_declaration();
        } else if word == "proc" {
            this.first_non_include_passed = true;
            this.move_word(word);
            this.proc_declaration();
        } else if word == "include" {
            assert !this.first_non_include_passed, "include declarations are only allowed at the top";
            this.move_word(word);
            this.include_declaration();
        } else {
            this.first_non_include_passed = true;
            this.statement();
        }
    }
    statement() {
        this.expression_statement();
    }
    memory_declaration() {
        let name = this.next_word();
        assert this.memory[name] == nil, "memory redefinition";
        this.trim();
        let size = this.resolve_const_expression();
        this.memory[name] = this.mem_capacity;
        this.mem_capacity = this.mem_capacity + size;
    }
    resolve_const_expression() {
        let found = false;
        let stack = Stack();
        this.stack = stack;
        this.processing_const = true;

        while !found {
            let word = this.peek_word();
            if word == "end" {
                this.move_word(word);
                found = true;
            } else {
                this.expression();
            }
        }

        this.processing_const = false;
        let n = stack.resolve();

        return n;
    }
    const_declaration() {
        let name = this.next_word();
        assert this.consts[name] == nil, "const redefinition";
        this.trim();

        let n = this.resolve_const_expression();
        
        this.consts[name] = n;
    }
    proc_declaration() {
        let name = this.next_word();
        assert this.procs[name] == nil, "proc redefinition";
        this.trim();
        let block = this.open_block(BlockType.Proc);
        this.write_line(`    jmp proc_end_{block.id}`);
        this.write_line(`proc_start_{block.id}:`);
        this.write_line(`    mov [ret_stack_rsp], rsp`);
        this.write_line(`    mov rsp, rax`);
        this.procs[name] = block.id;
    }
    include_declaration() {
        this.trim();
        assert this.matches("\""), "expected path to file to include";
        this.ptr = this.ptr + 1;
        let path = this.read_string();

        // Already included
        if this.included[path] {
            return;
        }

        let prev_source = this.source;
        let prev_ptr = this.ptr;

        this.ptr = 0;
        this.source = read_file(path);

        this.lex();

        this.source = prev_source;
        this.ptr = prev_ptr;

        this.included[path] = true;
        // the included file can modify this
        // when an inclusion is finished, we know we have not reached another declaration yet
        this.first_non_include_passed = false;
    }
    expression_statement() {
        this.expression();
    }
    peek(n) {
        if this.ptr + n < this.source.length {
            return this.source[this.ptr + n];
        }
        return nil;
    }
    expression() {
        this.trim();
        let current = this.peek(0);
        if current == nil {
            return;
        }
        if current == "/" {
            if this.peek(1) == "/" {
                this.skip_line();
            }
        } else if current == "\"" {
            this.ptr = this.ptr + 1;
            this.string();
        } else if is_digit(current) {
            this.number();
        } else {
            let word = this.next_word();
            if word == "argv" {
                this.emit(Op(OpCode.Argv, 0));
            } else if word == "argc" {
                this.emit(Op(OpCode.Argc, 0));
            } else if word == "+" {
                this.emit(Op(OpCode.Add, 0));
            } else if word == "-" {
                this.emit(Op(OpCode.Sub, 0));
            } else if word == "*" {
                this.emit(Op(OpCode.Mul, 0));
            } else if word == "=" {
                this.emit(Op(OpCode.Equal, 0));
            } else if word == "divmod" {
                this.emit(Op(OpCode.Divmod, 0));
            }  else if word == "!=" {
                this.emit(Op(OpCode.NotEqual, 0));
            } else if word == "<" {
                this.emit(Op(OpCode.Lt, 0));
            } else if word == ">" {
                this.emit(Op(OpCode.Gt, 0));
            } else if word == "shl" {
                this.emit(Op(OpCode.Shl, 0));
            } else if word == "shr" {
                this.emit(Op(OpCode.Shr, 0));
            } else if word == "bor" {
                this.emit(Op(OpCode.Bor, 0));
            } else if word == "band" {
                this.emit(Op(OpCode.Band, 0));
            } else if word == "@8" {
                this.emit(Op(OpCode.Load8, 0));
            } else if word == "!8" {
                this.emit(Op(OpCode.Store8, 0));
            } else if word == "@16" {
                this.emit(Op(OpCode.Load16, 0));
            } else if word == "!16" {
                this.emit(Op(OpCode.Store8, 0));
            } else if word == "@32" {
                this.emit(Op(OpCode.Load32, 0));
            } else if word == "!32" {
                this.emit(Op(OpCode.Store32, 0));
            } else if word == "@64" {
                this.emit(Op(OpCode.Load64, 0));
            } else if word == "!64" {
                this.emit(Op(OpCode.Store64, 0));
            } else if word == "syscall1" {
                this.emit(Op(OpCode.Syscall1, 0));
            } else if word == "syscall2" {
                this.emit(Op(OpCode.Syscall2, 0));
            } else if word == "syscall3" {
                this.emit(Op(OpCode.Syscall3, 0));
            } else if word == "syscall4" {
                this.emit(Op(OpCode.Syscall4, 0));
            } else if word == "syscall5" {
                this.emit(Op(OpCode.Syscall5, 0));
            } else if word == "syscall6" {
                this.emit(Op(OpCode.Syscall6, 0));
            } else if word == "dup" {
                this.emit(Op(OpCode.Dup, 0));
            } else if word == "swap" {
                this.emit(Op(OpCode.Swap, 0));
            } else if word == "over" {
                this.emit(Op(OpCode.Over, 0));
            } else if word == "drop" {
                this.emit(Op(OpCode.Drop, 0));
            } else if word == "rotate" {
                this.emit(Op(OpCode.Rotate, 0));
            } else if word == "if" {
                this.if_statement();
            } else if word == "end" {
                this.end_statement();
            } else if word == "else" {
                this.else_statement();
            } else if word == "while" {
                this.while_statement();
            } else if word == "do" {
                this.do_statement();
            } else {
                if this.consts[word] {
                    this.write_const(word);
                } else if this.memory[word] {
                    this.write_memory(word);
                } else if this.procs[word] {
                    this.call_proc(word);
                } else {
                    assert false, `line {this.line + 1}: unknown keyword '{word}'`;
                }
            }
        }
    }
    open_block(type) {
        let new_block = Block(this.block_counter, type);
        this.block_counter = this.block_counter + 1;
        new_block.prev = this.blocks;
        this.blocks = new_block;
        return new_block;
    }
    close_block() {
        let current_block = this.blocks;
        let prev_block = this.blocks.prev;
        this.blocks = prev_block;
        return current_block;
    }
    while_statement() {
        let block = this.open_block(BlockType.While);
        this.write_line(`;; -- while -- `);
        this.write_line(`while_start_{block.id}:`);
    }
    do_statement() {
        assert this.blocks.type == BlockType.While, "do only available after while";
        this.write_line(`;; -- do -- `);
        this.write_line(`    pop rax`);
        this.write_line(`    cmp rax, 1`);
        this.write_line(`    jne while_end_{this.blocks.id}`);
    }
    if_statement() {
        let else_block = this.open_block(BlockType.If);
        this.write_line(`;; -- if -- `);
        this.write_line(`    pop rax`);
        this.write_line(`    cmp rax, 1`);
        this.write_line(`    jne addr_{else_block.id}`);
    }
    else_statement() {
        let else_block = this.close_block();
        assert else_block.type == BlockType.If, "else only available after if";
        let end_block = this.open_block(BlockType.Else);
        this.write_line(`    jmp addr_{end_block.id}`);
        this.write_line(`;; -- else -- `);
        this.write_line(`addr_{else_block.id}:`);
    }
    end_statement() {
        let block = this.close_block();
        if block.type == BlockType.Else {
            this.write_line(`    jmp addr_{block.id}`);
            this.write_line(`;; -- end -- `);
            this.write_line(`addr_{block.id}:`);
        } else if block.type == BlockType.If {
            this.write_line(`;; -- end -- `);
            this.write_line(`addr_end_{block.id}:`);
        } else if block.type == BlockType.While {
            this.write_line(`    jmp while_start_{block.id}`);
            this.write_line(`;; -- end -- `);
            this.write_line(`while_end_{block.id}:`);
        } else if block.type == BlockType.Proc {
            this.write_line(`;; -- proc end -- `);
            this.write_line(`    mov rax, rsp`);
            this.write_line(`    mov rsp, [ret_stack_rsp]`);
            this.write_line(`    ret`);
            this.write_line(`proc_end_{block.id}:`);
        }
    }
    read_number() {
        let num = "";
        while this.ptr < this.source.length and is_digit(this.source[this.ptr]) {
            num = num + this.source[this.ptr];
            this.ptr = this.ptr + 1;
        }
        return num;
    }
    number() {
        this.emit(Op(OpCode.PushInt, parse_number(this.read_number())));
    }
    read_string() {
        let str = "";
        while this.ptr < this.source.length and this.source[this.ptr] != "\"" {
            str = str + this.source[this.ptr];
            this.ptr = this.ptr + 1;
        }
        this.ptr = this.ptr + 1;
        return str;
    }
    string() {
        let str = this.read_string();
        this.emit(Op(OpCode.PushString, str));
    }
    emit(op) {
        if this.processing_const {
            assert op.type == OpCode.PushInt
                or op.type == OpCode.Add
                or op.type == OpCode.Mul
                or op.type == OpCode.Sub, "Only numbers and additions supported in constant expressions";
            this.stack.push(op);
        } else {
            if op.type == OpCode.Argv {
                this.write_line(`    mov rax, [args_ptr]`);
                this.write_line("    add rax, 8");
                this.write_line("    push rax");
            } else if op.type == OpCode.Argc {
                this.write_line(`    mov rax, [args_ptr]`);
                this.write_line("    mov rax, [rax]");
                this.write_line("    push rax");
            } else if op.type == OpCode.PushInt {
                this.write_line(`    mov rax, {op.operand}`);
                this.write_line("    push rax");
            } else if op.type == OpCode.PushString {
                let idx = this.add_string(op.operand);
                this.write_line(`    mov rax, {op.operand.length}`);
                this.write_line("    push rax");
                this.write_line(`    push str_{idx}`);
            } else if op.type == OpCode.PushMem {
                this.write_line(`    push mem + {op.operand}`);
            } else if op.type == OpCode.Add {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    add rax, rbx");
                this.write_line("    push rax");
            } else if op.type == OpCode.Sub {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    sub rbx, rax");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Mul {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    mul rbx");
                this.write_line("    push rax");
            } else if op.type == OpCode.Divmod {
                this.write_line("    xor rdx, rdx");
                this.write_line("    pop rbx");
                this.write_line("    pop rax");
                this.write_line("    div rbx");
                this.write_line("    push rax");
                this.write_line("    push rdx");
            } else if op.type == OpCode.Equal {
                this.write_line("    mov rcx, 0");
                this.write_line("    mov rdx, 1");
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    cmp rax, rbx");
                this.write_line("    cmove rcx, rdx");
                this.write_line("    push rcx");
            } else if op.type == OpCode.NotEqual {
                this.write_line("    mov rcx, 0");
                this.write_line("    mov rdx, 1");
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    cmp rax, rbx");
                this.write_line("    cmovne rcx, rdx");
                this.write_line("    push rcx");
            } else if op.type == OpCode.Lt {
                this.write_line("    mov rcx, 0");
                this.write_line("    mov rdx, 1");
                this.write_line("    pop rbx");
                this.write_line("    pop rax");
                this.write_line("    cmp rax, rbx");
                this.write_line("    cmovl rcx, rdx");
                this.write_line("    push rcx");
            } else if op.type == OpCode.Gt {
                this.write_line("    mov rcx, 0");
                this.write_line("    mov rdx, 1");
                this.write_line("    pop rbx");
                this.write_line("    pop rax");
                this.write_line("    cmp rax, rbx");
                this.write_line("    cmovg rcx, rdx");
                this.write_line("    push rcx");
            } else if op.type == OpCode.Shr {
                this.write_line("    pop rcx");
                this.write_line("    pop rbx");
                this.write_line("    shr rbx, cl");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Shl {
                this.write_line("    pop rcx");
                this.write_line("    pop rbx");
                this.write_line("    shl rbx, cl");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Bor {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    or rbx, rax");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Band {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    and rbx, rax");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Dup {
                this.write_line("    pop rax");
                this.write_line("    push rax");
                this.write_line("    push rax");
            } else if op.type == OpCode.Swap {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    push rax");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Over {
                this.write_line("    pop rbx");
                this.write_line("    pop rax");
                this.write_line("    push rax");
                this.write_line("    push rbx");
                this.write_line("    push rax");
            } else if op.type == OpCode.Drop {
                this.write_line("    pop rax");
            } else if op.type == OpCode.Rotate {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    pop rcx");
                this.write_line("    push rbx");
                this.write_line("    push rax");
                this.write_line("    push rcx");
            } else if op.type == OpCode.Call {
                this.write_line(`    ;; -- call --`);
                this.write_line(`    mov rax, rsp`);
                this.write_line(`    mov rsp, [ret_stack_rsp]`);
                this.write_line(`    call proc_start_{op.operand}`);
                this.write_line(`    mov [ret_stack_rsp], rsp`);
                this.write_line(`    mov rsp, rax`);
            } else if op.type == OpCode.Load8 {
                this.write_line("    pop rax");
                this.write_line("    xor rbx, rbx");
                this.write_line("    mov bl, [rax]");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Store8 {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    mov [rax], bl");
            } else if op.type == OpCode.Load16 {
                this.write_line("    pop rax");
                this.write_line("    xor rbx, rbx");
                this.write_line("    mov bx, [rax]");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Store16 {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    mov [rax], bx");
            } else if op.type == OpCode.Load32 {
                this.write_line("    pop rax");
                this.write_line("    xor rbx, rbx");
                this.write_line("    mov ebx, [rax]");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Store32 {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    mov [rax], ebx");
            } else if op.type == OpCode.Load64 {
                this.write_line("    pop rax");
                this.write_line("    xor rbx, rbx");
                this.write_line("    mov rbx, [rax]");
                this.write_line("    push rbx");
            } else if op.type == OpCode.Store64 {
                this.write_line("    pop rax");
                this.write_line("    pop rbx");
                this.write_line("    mov [rax], rbx");
            } else if op.type == OpCode.Syscall1 {
                this.write_line("    pop rax");
                this.write_line("    pop rdi");
                this.write_line("    syscall");
            } else if op.type == OpCode.Syscall2 {
                this.write_line("    pop rax");
                this.write_line("    pop rdi");
                this.write_line("    pop rsi");
                this.write_line("    syscall");
            } else if op.type == OpCode.Syscall3 {
                this.write_line("    pop rax");
                this.write_line("    pop rdi");
                this.write_line("    pop rsi");
                this.write_line("    pop rdx");
                this.write_line("    syscall");
            } else if op.type == OpCode.Syscall4 {
                this.write_line("    pop rax");
                this.write_line("    pop rdi");
                this.write_line("    pop rsi");
                this.write_line("    pop rdx");
                this.write_line("    pop r10");
                this.write_line("    syscall");
            } else if op.type == OpCode.Syscall5 {
                this.write_line("    pop rax");
                this.write_line("    pop rdi");
                this.write_line("    pop rsi");
                this.write_line("    pop rdx");
                this.write_line("    pop r10");
                this.write_line("    pop r8");
                this.write_line("    syscall");
            } else if op.type == OpCode.Syscall6 {
                this.write_line("    pop rax");
                this.write_line("    pop rdi");
                this.write_line("    pop rsi");
                this.write_line("    pop rdx");
                this.write_line("    pop r10");
                this.write_line("    pop r8");
                this.write_line("    pop r9");
                this.write_line("    syscall");
            }
        }
    }
    write_line(content) {
        this.output = this.output + content + "\n";
    }
    write_memory(name) {
        this.emit(Op(OpCode.PushMem, this.memory[name]));
    }
    write_const(name) {
        this.emit(Op(OpCode.PushInt, this.consts[name]));
    }
    call_proc(name) {
        let id = this.procs[name];
        this.emit(Op(OpCode.Call, id));
    }
    add_string(s) {
        let idx = this.str_count;
        this.data = `{this.data}\n    str_{this.str_count}: db "{s}"`;
        this.str_count = this.str_count + 1;
        return idx;
    }
    write(dst) {

        let contents = `
section .text
    global _start
_start:
    mov [args_ptr], rsp
    mov rax, ret_stack_end
    mov [ret_stack_rsp], rax
{this.output}
    mov rax, 60
    mov rdi, 0
    syscall

section .data
{this.data}
section .bss
args_ptr: resq 1
ret_stack_rsp: resq 1
ret_stack: resb 4096
ret_stack_end:
mem: resb {this.mem_capacity}
`;
        write_file(dst, contents);
    }
}


let source = read_file("./orth/main.orth");

let compiler = Lexer(source);

compiler.lex();

compiler.write("./orth/output.asm");

let stdout = cmd("bash /mnt/d/ws/r_scan/orth/run.sh");

print stdout;
